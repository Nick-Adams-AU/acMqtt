bridge = '192.168.10.15' -- Obviously change to suit environment
checkForChanges = true -- When true the script will periodically check for create/update/delete of object keywords (disable to lower CPU load)

--[[
Gateway between an Automation Controller and Philips Hue bridge

Script: 'HUE send receive', resident zero sleep

Permission to use/modify freely is granted, and acknowledging the author or sending beer would be nice.

>>> HUE

For Philips Hue devices, bi-directional sync with CBus occurs. Add the keyword 'HUE' to CBus objects, plus...
  pn= Preferred name (which needs to match exactly the name of the Hue device.)

Keyword examples:

HUE, pn=Steve's bedside light
HUE, pn=Steve's electric blanket

A useful result is that Philips Hue devices can then be added to CBus scenes, like an 'All off' function.

The CBus groups for Hue devices are usually not used for any purpose other than controlling their Hue device.
Turning on/off one of these groups will result in the Philips Hue hub turning the loads on/off. It is possible
that these CBus Hue groups could be used to also control CBus loads, giving them dual purpose.

Note: This script only handles on/off, as well as levels for dimmable Hue devices, but not colours/colour
temperature, as that's not a CBus thing. Colour details will return to previously set values done in the Hue app.
--]]


logging = false        -- Enable detailed logging
logms = false          -- Include timestamp in milliseconds for logs

storage.set('hueactive', nil)

eventStream = '/eventstream/clip/v2'
resource = '/clip/v2/resource'
connectivity = '/clip/v2/resource/zigbee_connectivity'
clientKeyStorage = 'huesendreceive'
socketTimeout = 0.25   -- Lower = higher CPU, but this is dynamic... During ramp events the timeout is set to 0.01 seconds
checkChanges = 30      -- Interval in seconds to check for changes to object keywords
ignoreTimeout = 2      -- Timeout for stale ignore messages in seconds (two seconds is a long time...)
rampTimeout = 8        -- Time beyond ramp to declare a ramp orphan in seconds
sendHeartbeat = 5      -- Send a heartbeat to the 'Heartbeat' script every n seconds (zero to disable heartbeat)

huePort = 5435
port = 443
protocol = 'tlsv12'

hue = {}               -- Hue device details (name, state, dimmable, etc) 
hueDevices = {}        -- Quick lookup to determine whether an object is a Hue device
hueDeviceStatus = {}   -- Hue device status
hueConnected = false   -- Receiving event stream?
hueIds = {}            -- Lookup Hue object ID from metadata name
hueV1Ids = {}          -- Lookup Hue object ID from metadata name
cbusMessages = {}      -- Incoming message queue
bridgeMessages = {}    -- Incoming message queue
ignoreCbus = {}        -- To prevent message loops
ignoreBridge = {}      -- To prevent message loops
ramp = {}              -- Keeps track of CBus ramping to ignore some zero level publish events outstandingCbusMessage()
pendingEndRamp = {}    -- Keeps track of Hue ramping
nonTargetUpdate = false -- Watch for non-ramp target Hue updates 

started = socket.gettime(); function logger(msg) if logms then ts = string.format('%.3f ', socket.gettime()-started) else ts = '' end log(ts..msg) end -- Log helper
function len(dict) local i = 0; local k; for k, _ in pairs(dict) do i = i + 1 end return(i) end -- Get number of dictionary members

heartbeat = os.time()


--[[
UDP listener - receive messages from the event script 'HUE'
--]]

server = require('socket').udp()
server:settimeout(socketTimeout)
if not server:setsockname('127.0.0.1', huePort) then -- Listen on huePort for Hue object changes
  logger('Error: Could not listen on port '..huePort)
  storage.set('hueactive', true) -- Ensure that Heartbeat can re-start this script
  socket.sleep(60)
  do return end
end


--[[
Representational state transfer (REST) 
--]]

local http = require('socket.http')
local ltn12 = require('ltn12')

function rest(method, cmd, body)
  if not body then body = '' end
  local respbody = {}
  local headers = {["content-length"] = tostring(#body)}
  if clientKey ~= nil then headers['hue-application-key'] = clientKey end
  local result, respcode, respheaders, respstatus = http.request {
    method = method,
    url = 'https://'..bridge..cmd,
    source = ltn12.source.string(body),
    headers = headers,
    sink = ltn12.sink.table(respbody)
  }
  if respcode ~= 200 then
    local j = json.decode(respbody[1])
    logger('Error: Received response '..respcode..' requesting '..method..' '..cmd..' '..j.errors[1].description)
  end
  return table.concat(respbody)
end


--[[
Retrieve or create the client key 
--]]

clientKey = storage.get(clientKeyStorage)
if clientKey == nil then
  logger('Press the Hue bridge link button')
  repeat
    response = json.decode(rest('POST', '/api', '{"devicetype":"cbus#ac", "generateclientkey": true}'))[1]
    if response.error and response.error.description:find('not pressed') then
      logger('Waiting for link button...')
      socket.sleep(5)
    end
  until response.success
  clientKey = response.success.username
  storage.set(clientKeyStorage, clientKey)
end


--[[
Load lighting devices from the bridge (REST call or in response to the event stream)
--]]

function getResources(msg)
  local discovered = nil
  if not msg then
    if logging then logger('Get light devices') end
    msg = json.decode(rest('GET', resource..'/light'))
  end
  for _, d in ipairs(msg.data) do
    if d.type == 'light' and not hueDeviceStatus[d.id_v1] then
      if discovered == nil then discovered = {} end
      hueDeviceStatus[d.id_v1] = {id = d.id, rid = d.owner.rid, name = d.metadata.name, on = d.on.on}
      if d.dimming then
        hueDeviceStatus[d.id_v1].brightness = d.dimming.brightness; hueDeviceStatus[d.id_v1].level = CBusPctToLevel(math.ceil(d.dimming.brightness))
      else
        hueDeviceStatus[d.id_v1].level = (d.on.on and 255) or 0
      end
      local dmsg = json.decode(rest('GET', resource..'/device/'..d.owner.rid))
      local s
      for _, s in ipairs(dmsg['data'][1].services) do
        if s.rtype == 'zigbee_connectivity' then hueDeviceStatus[d.id_v1].zid = s.rid break end
      end
      hueDeviceStatus[d.id_v1].reachable = json.decode(rest('GET', connectivity..'/'..hueDeviceStatus[d.id_v1].zid))['data'][1].status == 'connected'

      hueIds[d.metadata.name] = d.id
      hueV1Ids[d.metadata.name] = d.id_v1
      discovered[d.id_v1] = hueDeviceStatus[d.id_v1]
    end
  end
  if discovered ~= nil then
    local ds = ''
    for _, d in pairs(discovered) do
      ds = ds..'\n'..d.name..', id: '..d.id -- ..', rid: '..d.rid
    end
    logger('Discovered devices:'..ds)
  end
end


--[[
Connect to the bridge and initiate event stream 
--]]

require('ssl')
sock = require('socket').tcp()

res, err = sock:connect(bridge, port)
if res then
  sock = ssl.wrap(sock, protocol)
  res, err = sock:dohandshake()
  if res then
    logger('Connected to Philips Hue bridge')
    sock:settimeout(socketTimeout)
    getResources()
    sock:send('GET '..eventStream..' HTTP/1.1\nHost: '..bridge..'\nAccept: text/event-stream\nhue-application-key: '..clientKey..'\n\n')
  else
    logger('Handshake failed: '..tostring(err))
    sock:close()
    do return end
  end
else
  logger('Connect failed: '..tostring(err))
  sock:close()
  do return end
end


--[[
Create / update / delete Hue devices
--]]
function cudHue(initial)
  local grps = GetCBusByKW('HUE', 'or')
  local found = {}
  local addition = false
  local k, v

  for k, v in pairs(grps) do
    local net = tonumber(v['address'][1]); local app = tonumber(v['address'][2]); local group = tonumber(v['address'][3])
    local pn = GetCBusGroupTag(net, app, group)
    local alias = net..'/'..app..'/'..group

    table.insert(found, alias)
    if not hue[alias] then hue[alias] = {}; addition = true end

    local tags = v['keywords']
    for _, t in ipairs(tags) do
      tp = string.split(t, '=')
      tp[1] = trim(tp[1])
      if tp[2] then tp[2] = trim(tp[2]) if tp[1] == 'pn' then pn = tp[2] end end
    end
    hue[alias].name = pn
    hue[alias].hueid = hueIds[pn]
    hue[alias].hueV1id = hueV1Ids[pn]
    if initial then
      if not ramp[alias] and not pendingEndRamp[alias] then -- Do not mess with the CBusLevel during ramping
        local level = nil; pcall(function () level = GetCBusLevel(net, app, group) end); if not level then level = -1 end
        local hueLevel = hueDeviceStatus[hueV1Ids[pn] ].level
        if level ~= hueLevel and hueDeviceStatus[hueV1Ids[pn] ].on then
          if logging then logger('Adjusting '..alias..' to match Hue, on=true, level='..level..', hueLevel='..hueLevel) end
          SetCBusLevel(net, app, group, hueLevel, 0)
        end
        if level > 0 and not hueDeviceStatus[hueV1Ids[pn] ].on then
          if logging then logger('Adjusting '..alias..' to match Hue, on=false, level='..level..', hueLevel='..hueLevel) end
          SetCBusLevel(net, app, group, 0, 0)
        end
      end
    end
    if not hue[alias].state then hue[alias].state = hueState end
    if not storage.get('pre'..alias) then storage.set('pre'..alias, hueLevel) end
    hue[alias].state = level
    hueDevices[pn] = alias
    hueDeviceStatus[hueV1Ids[pn]].alias = alias
    if hueDeviceStatus[hueV1Ids[pn]].brightness ~= nil then hue[alias].dimmable = true end
  end
    
  -- Handle deletions
  for k, _ in pairs(hue) do
    local f = false; for _, v in ipairs(found) do if k == v then f = true; break end end
    if not f then
      kill = hue[k].name; hue[k] = nil; hueDevices[kill] = nil
    end
  end
end


--[[
Last level storage
--]]

lastLevel = storage.get('lastlvl', {})

function saveLastLevel()
  -- Get old levels to see if anything changed
  local oldLastLevel = storage.get('lastlvl', {})
  local changed = {}
  local k, v

  for k, v in pairs(lastLevel) do
    if oldLastLevel[k] == nil or oldLastLevel[k] ~= v then -- Add to changes
      changed[#changed + 1] = k..' '..tostring(oldLastLevel[k])..'->'..tostring(v)
    end
  end

  if #changed then
    storage.set('lastlvl', lastLevel)
    if logging then logger('Saved last levels. Object(s) changed: '..table.concat(changed, ', ')) end
  end
end

function checkNewLastLevel(alias)
  local parts = string.split(alias, '/')
  local target = GetCBusTargetLevel(tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3]))
  if target ~= 0 then
    if target ~= lastLevel[alias] then
      lastLevel[alias] = target
      if logging then logger('Set lastLevel to '..target..' for '..alias) end
      saveLastLevel()
    end
  end
end


--[[
Publish Philips Hue objects to bridge
--]]
function publishHue(alias, level, rampRate)
  local state = (level ~= 0) and true or false
  local hueState
  local payload = {}

  payload.on = state
  if hue[alias].dimmable then
    hueState = level
    payload.bri = level
    if rampRate then payload.transitiontime = rampRate*10; nonTargetUpdate = false end
  else
    hueState = state
  end
  
  if ignoreBridge[alias] and (socket.gettime() - ignoreBridge[alias] > ignoreTimeout) then
    ignoreBridge[alias] = nil
    if logging then logger('Ignoring older bridge ignore flag for '..alias) end
  end
  if not ignoreBridge[alias] then
    local toPut = json.encode(payload)
    local resource = '/api/'..clientKey..hueV1Ids[hue[alias].name]..'/state'
    if logging then logger('PUT '..resource..' '..toPut) end
    rest('PUT', resource, toPut)
    -- Publishing to the bridge here will result in outstandingBridgeMessage() below setting the CBus state for the group.
    -- This is undesired, so ignoreCbus[alias] is used to ensure that the bridge change received does not set CBus.
    if hueState ~= hue[alias].state then ignoreCbus[alias] = socket.gettime(); if logging then logger('Setting ignoreCBus for '..alias) end end
    if logging then logger('Published Hue state and level '..hue[alias].name..' to '..toPut) end
  else
    ignoreBridge[alias] = nil
    if logging then logger('Ignoring bridge publish for '..alias) end
  end
  hue[alias].state = hueState
end


--[[
Publish the next queued messages from CBus to bridge
--]]

function outstandingCbusMessage()
  local cmd
  for _, cmd in ipairs(cbusMessages) do
    local parts = string.split(cmd, '/')
    local alias = parts[1]..'/'..parts[2]..'/'..parts[3]
    local sKey = 'pre'..alias
    
    local net = tonumber(parts[1]); local app = tonumber(parts[2]); local group = tonumber(parts[3])
    local setting = true
    local setRamp = false
    local payload = tonumber(parts[4])
    if payload == nil then logger('Warning: Nil level for '..alias); do return end end

    if not hueDeviceStatus[hueV1Ids[hue[alias].name]].reachable then
      if storage.get(sKey) then
        SetCBusLevel(net, app, group, storage.get(sKey), 0)
        logger('Warning: No connectivity for '..hue[alias].name..' reverting '..alias..' to previous value')
        ignoreBridge[alias] = socket.gettime() if logging then logger('Setting ignoreBridge for '..alias) end
      end
      goto next
    end
    
    if not ramp[alias] then
      if not setRamp then checkNewLastLevel(alias) end
      setRamp = true
      if GetCBusRampRate(net, app, group) > 0 then
        ramp[alias] = { ts = socket.gettime(), ramp = GetCBusRampRate(net, app, group), target = GetCBusTargetLevel(net, app, group) }
        if logging then logger('Set ramp for '..alias) end
        if pendingEndRamp[alias] then pendingEndRamp[alias] = nil; if logging then logger('Removing previous pending end ramp for '..alias) end end
      end
    else
      if ramp[alias].target ~= GetCBusTargetLevel(net, app, group) then -- Target level has changed so cancel ramp
        ramp[alias] = nil
        if logging then logger('Cancel ramp for '..alias) end
        if payload == 0 and GetCBusRampRate(net, app, group) > 0 then setting = false end -- Ignore initial zero if ramp on
      end
    end
    if setting then
      if setRamp then publishHue(alias, (ramp[alias] and ramp[alias].target) or payload, (ramp[alias] and ramp[alias].ramp) or nil) end
      if ramp[alias] and socket.gettime()-ramp[alias].ts > 1 and payload == ramp[alias].target then
        if logging then logger('Set pending end ramp for '..alias) end
        pendingEndRamp[alias] = {ts = socket.gettime(), rampts = ramp[alias].ts, ramp = ramp[alias].ramp, target = ramp[alias].target}
        ramp[alias] = nil
        if logging then logger('Clear ramp for '..alias) end
      end
      local p = payload
      if tonumber(payload) then p = string.format('%.3f', payload) end
      storage.set(sKey, p) -- Save payload as 'previous' for use in the HUE event-based script
    end
    ::next::
  end
  cbusMessages = {}
end

--[[
Remove any orphaned ramp flags
--]]
function checkRampOrphans()
  local k, v; local orphan = {}
  for k, v in pairs(ramp) do
    if socket.gettime() > v.ts + v.ramp + rampTimeout then
      -- Is an older ramp timestamp beyond ramp duration plus margin (should never occur, but does occasionally)
      table.insert(orphan, k)
    end
  end
  for _, k in ipairs(orphan) do ramp[k] = nil; if logging then logger('Removing orphaned ramp for '..k) end end
end


--[[
Publish the next queued messages from bridge to CBus
--]]
function outstandingBridgeMessage()
  local level, oldState, msg
  for _, msg in ipairs(bridgeMessages) do
    local id = msg.id
    local alias = hueDeviceStatus[id].alias
    local forceBridge = false
    local lvl
    
    if not alias then goto next end

    local parts = string.split(alias, '/')
    local net = parts[1]; local app = parts[2]; local group = parts[3]
    if ignoreCbus[alias] and socket.gettime() - ignoreCbus[alias] > ignoreTimeout then -- Don't worry about older 'ignore' flags
      ignoreCbus[alias] = nil
      if logging then logger('Ignoring older CBus ignore flag for '..alias) end
    end
    if hueDeviceStatus[id].brightness ~= nil then
      -- Dimmable
      if hue[alias].dimmable == nil then hue[alias].dimmable = true end
      level = (hueDeviceStatus[id].on and hueDeviceStatus[id].level) or 0
    else
      level = (hueDeviceStatus[id].on and 255) or 0
    end
    if not ignoreCbus[alias] then -- Only set the CBus status/level if this script did not initiate the change
      if hueDeviceStatus[id].brightness ~= nil then
        -- Dimmable
        if pendingEndRamp[alias] then
          if nonTargetUpdate and pendingEndRamp[alias].target == level and socket.gettime() - pendingEndRamp[alias].rampts >= pendingEndRamp[alias].ramp-1 then
            if logging then logger('Cleared pending end ramp for '..alias) end
            pendingEndRamp[alias] = nil
          else
            do return end
          end
        end
        if not ramp[alias] and not pendingEndRamp[alias] then
          lvl = nil; local stat, err = pcall(function () lvl = GetCBusLevel(net, app, group) end)
          -- log('lvl='..tostring(lvl)..', stat='..tostring(stat)..', err='..tostring(err)..', level='..level..', msg.on='..tostring(msg.on)..', msg.lvl='..tostring(msg.lvl))
          if lvl ~= level then
            if msg.on and not msg.lvl then -- No level set, so return to lastLevel
              if level > 0 and level ~= lastLevel[alias] then
                forceBridge = true  -- If HueDeviceStatus level is different to lastLevel then force a bridge message
                level = lastLevel[alias]
              end
            end
            if logging then logger('Setting '..alias..' to '..level..tostring((forceBridge and ' (last level)') or '')) end
            SetCBusLevel(net, app, group, level, 0)
          end
        else
          if logging then logger('Not setting '..alias..' - ramp in progress') end
        end
      else
        -- Switchable
        local state = nil; pcall(function () state = GetCBusState(net, app, group) end)
        lvl = (state and 255) or 0
        if state ~= hueDeviceStatus[id].on then
          if logging then logger('Setting '..alias..' to '..tostring(hueDeviceStatus[id].on)) end
          SetCBusState(net, app, group, hueDeviceStatus[id].on)
        end
      end
      oldState = hue[alias].state
      if not ramp[alias] and not pendingEndRamp[alias] then
        -- Setting CBus here will result in the HUE event script requesting publication of the state using publishHue() above.
        -- This is undesired, so ignoreBridge[alias] is used to ensure that the CBus change received does not publish to the bridge.
        if not forceBridge and oldState ~= level and lvl ~= level then ignoreBridge[alias] = socket.gettime() if logging then logger('Setting ignoreBridge for '..alias..', oldState='..tostring(oldState)..' level='..tostring(level)) end end
      end
    else
      ignoreCbus[alias] = nil
      if logging then logger('Ignoring CBus publish for '..alias) end
    end
    if not hueDeviceStatus[id].on then
      hue[alias].state = 0
    else
      hue[alias].state = level
    end
    ::next::
  end
  bridgeMessages = {}
end

--[[
Remove any orphaned pending end ramp flags
--]]
function checkEndRampOrphans()
  local k, v; local orphan = {}
  for k, v in pairs(pendingEndRamp) do
    if socket.gettime() - v.rampts > v.ramp + rampTimeout then
      table.insert(orphan, k)
    end
  end
  for _, k in ipairs(orphan) do pendingEndRamp[k] = nil; if logging then logger('Removing orphaned pending end ramp for '..k) end end
end


--[[
Bridge update message
--]]

function updateMessage(msg)
  if msg.type == 'update' then
    for _, d in ipairs(msg.data) do
      if d.type == 'light' then
        local update = false
        local id = d.id_v1
        local on = nil; if d.on then on = d.on.on; update = true end
        local bri = nil; local lvl = nil; if d.dimming then
          update = true
          bri = d.dimming.brightness; lvl = CBusPctToLevel(math.ceil(bri)) -- PctToLevel does not work with fractional numbers. Hue goes down to 0.39 as lowest brightness
          local alias = hueDeviceStatus[id].alias
          local target = nil
          if ramp[alias] then target = ramp[alias].target end
          if pendingEndRamp[alias] then target = pendingEndRamp[alias].target end
          if lvl ~= target and not nonTargetUpdate then nonTargetUpdate = true; if logging then logger('Non-target update received for '..alias) end end
        end
        if hueDeviceStatus[id] then
          if logging then logger('Hue event '..id..', on='..tostring(on)..', bri='..tostring(bri)..', lvl='..tostring(lvl)) end
          if on ~= nil then hueDeviceStatus[id].on = on end
          if bri ~= nil then hueDeviceStatus[id].brightness = bri; hueDeviceStatus[id].level = lvl end
          if d.metadata ~= nil and d.metadata.name ~= hueDeviceStatus[id].name then -- Device has been renamed
            local oldName = hueDeviceStatus[id].name
            logger('Device '..oldName..' renamed to '..d.metadata.name)
            hueDeviceStatus[id].name = d.metadata.name
            hueIds[d.metadata.name] = hueIds[oldName]; hueIds[oldName] = nil
            hueV1Ids[d.metadata.name] = hueV1Ids[oldName]; hueV1Ids[oldName] = nil
          end
          if update then
            bridgeMessages[#bridgeMessages + 1] = {id = id, on = on, lvl = lvl } -- Queue update
          end
        end
      elseif d.type == 'zigbee_connectivity' then
        local id = d.id_v1
        local status = nil; if d.status then status = d.status end
        if hueDeviceStatus[id] then
          if status ~= nil  then if status == 'connected' then hueDeviceStatus[id].reachable = true else hueDeviceStatus[id].reachable = false end end
        end
        if status then
          logger(hueDeviceStatus[id].name..' is '..tostring((hueDeviceStatus[id].reachable and 'reachable') or 'NOT reachable'))
        end
      end
    end
  elseif msg.type == 'delete' then
    for _, d in ipairs(msg.data) do
      if d.type == 'light' then
        local id = d.id_v1
        if hueDeviceStatus[id] then
          logger('Device '..hueDeviceStatus[id].name..' deleted')
          hueIds[hueDeviceStatus[id].name] = nil
          hueV1Ids[hueDeviceStatus[id].name] = nil
          hueDeviceStatus[id] = nil
        end
      end
    end
  elseif msg.type == 'add' then
    getResources(msg)
  end
end


--[[
Main loop
--]]

cud = {
  { func = cudHue, t = socket.gettime() - checkChanges, init = true, script = 'HUE' } -- Create/update/delete script(s)
}

-- Initial load of devices
for _, c in ipairs(cud) do if c.init then c.func(true); if c.script and script.status(c.script) ~= nil then script.disable(c.script); script.enable(c.script) end end end

function validateIncoming(cmd) -- Reject any weird socket messages received
  local _, count = cmd:gsub("/", ''); if count < 3 or count > 4 then return false end
  local parts = string.split(cmd, '/')
  local dstC, payload
  if parts[2] and parts[2] == '228' then dstC = 4; payload = parts[5] else dstC = 3; payload = parts[4] end -- Measurement app is four dest parts, else three
  if payload == nil then return false end
  for i = 1,dstC,1 do n = tonumber(parts[i], 10); if n == nil then return false end end -- Test whether any dst parts are not whole decimal numbers
  return true
end


while true do
  -- Read the bridge event stream. The entire socket buffer is collected each iteration
  repeat
    local line, err = sock:receive()

    if not err then
      sock:settimeout(0)
      if line then
        if line:find('data:') and not line:find('geofence_client') then
          local payload = line:split(': ')[2]
          local stat, err = pcall(function () j = json.decode(payload) end)
          if stat then
            local msg
            for _, msg in ipairs(j) do updateMessage(msg) end
          end
        elseif line:find(': hi') then
          logger('Receiving event stream')
          hueConnected = true
          storage.set('hueactive', true)
        end
      end
    else
      if err ~= 'wantread' then
        logger('Hue receive failed: ' .. tostring(err))
        sock:close()
        do return end
      end
    end
  until err == 'wantread'
  if not ramp and not pendingEndRamp then sock:settimeout(socketTimeout) else sock:settimeout(0.01) end

  -- Check for new messages from CBus. The entire socket buffer is collected each iteration
  local more = false
  local stat, err = pcall(function ()
    ::checkAgain::
    local cmd = server:receive()
    if cmd and type(cmd) == 'string' then
      if validateIncoming(cmd) then
        cbusMessages[#cbusMessages + 1] = cmd -- Queue the new message
      else
        logger('Invalid command received: '..cmd)
      end
      server:settimeout(0); more = true; goto checkAgain -- Immediately check for more buffered inbound messages to queue
    else
      if more then if not ramp and not pendingEndRamp then server:settimeout(socketTimeout) else server:settimeout(0.01) end end
    end
  end)
  if not stat then logger('Socket receive error: '..err) end

  if #bridgeMessages > 0 then outstandingBridgeMessage() end -- Send outstanding messages to CBus
  if #cbusMessages > 0 then outstandingCbusMessage() end     -- Send outstanding messages to bridge
  if len(ramp) > 0 then checkRampOrphans() end               -- Some scenarios create ramp orphans
  if len(pendingEndRamp) > 0 then checkEndRampOrphans() end  -- Some scenarios create pending end ramp orphans
  if checkForChanges then                                    -- Periodically create/update/delete device items that change
    for _, c in ipairs(cud) do if socket.gettime() - c.t >=checkChanges then c.t = socket.gettime(); c.func() end end
  end

  --[[
  Send a heartbeat periodically to port 5433, listened to by the Heartheat script.
  If execution is disrupted by any error or lockup then this script will be re-started.
  If sending the heartbeat faults, then the loop is exited, which will also re-start this
  script (it being resident/sleep zero).
  --]]
  
  if sendHeartbeat > 0 then
    local stat, err = pcall(function ()
      if os.time() - heartbeat >= sendHeartbeat then
        heartbeat = os.time(); require('socket').udp():sendto('HUE send receive+'..heartbeat, '127.0.0.1', 5433)
      end
    end)
    if not stat then logger('A fault occurred sending heartbeat. Restarting...'); do return end end
  end
end