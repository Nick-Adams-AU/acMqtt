--[[
Resident, zero sleep, name: "MQTT lastlevel"

Maintain CBus 'lastlevels'

Used so that MQTT 'on' events can return a light/fan/blind to the last known set level.
Only monitors application 56 'lighting'.

Home Assistant with an MQTT integration and Google assistant only allows for on/off
("Hey Google, turn on the dunny light"), and not remembering the previous level set, so
this script, in conjunction with the MQTT script works around that. Setting another level
is not affected - just "on" commands.

This script also monitors keepalive messages from MQTT, and disables/enables that script
should it fail for whatever reason.
--]]

logging = false
lighting = {['56']=true} -- Array of applications that are used for lighting

maxHeartbeat = 20 -- Max period without a received heartbeat (seconds)
MQTTheartbeat = os.time()

server = require('socket').udp()
server:settimeout(0.1)
server:setsockname('127.0.0.1', 5433)

monitoring = {}
lastLevel = {}

function contains(prefix, text) local pos = text:find(prefix, 1, true) if pos then return pos >= 1 else return false end end


function saveLastLevel()
  -- Get old levels to see if anything changed
  local oldLastLevel = storage.get('lastlvl', {})
  local changed = {}
  local k, v

  for k, v in pairs(lastLevel) do
    if oldLastLevel[k] == nil or oldLastLevel[k] ~= v then -- Add to changes
      changed[#changed + 1] = k..' '..tostring(oldLastLevel[k])..'->'..tostring(v)
    end
  end
  
  if #changed then
    storage.set('lastlvl', lastLevel)
    log('Saved last levels. Object(s) changed: '..table.concat(changed, ', '))
  end
end


function checkQueue()
  local remove = {}
  local g, deets, ts

  for g, deets in pairs(monitoring) do
    if deets.current == deets.target then
      table.insert(remove, g)
      if deets.target ~= lastLevel[g] and deets.target ~= 0 then
        lastLevel[g] = deets.target
        if logging then log('Set lastLevel to '..deets.target..' for '..g) end
        saveLastLevel()
      end
    end
  
    if socket.gettime() > deets.ts + deets.ramp + 15 then -- Something has gone wrong, so terminate the monitor
      log('Warning: Terminate monitor for '..g..' (well beyond ramp duration)')
      table.insert(remove, g)
    end
  end

  local i
  for i=1,#remove do
    if logging then log('Stop monitor for '..remove[i]..' after '..string.format('%.3f', socket.gettime() - monitoring[remove[i]].ts)..' seconds') end
    monitoring[remove[i]] = nil -- Clean up removed monitors
  end
end

function checkRampTermination()
  local check = false
  if socket.gettime() - timeCheck >= 10 then
    timeCheck = socket.gettime()
    if #monitoring > 0 then check = true end -- Ensure failed monitors are periodically checked
  end

  for g, deets in pairs(monitoring) do
    local parts = string.split(g, '/')
    local rr = GetCBusRampRate(tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3]))
    if rr ~= deets.ramp then
      deets.current = grp.getvalue(g)
      deets.target = GetCBusTargetLevel(tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3]))
      check = true
    end
  end
  if check then checkQueue() end
end


lastLevel = storage.get('lastlvl', {})

log('MQTT lastlevel initialised')


while true do
  timeCheck = socket.gettime()

  -- Look for lastlevel values
  cmd = server:receive()
  if cmd and type(cmd) == 'string' then

    -- If the command contains a slash it's to start monitoring a group or provide an update
    if contains('/', cmd) then
      parts = string.split(cmd, '/')
      if lighting[parts[2]] then -- Only monitor the lighting application
        local alias = parts[1]..'/'..parts[2]..'/'..parts[3]
        local cl = tonumber(parts[4])
        if not monitoring[alias] then
          local tl = GetCBusTargetLevel(tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3]))
          local rr = GetCBusRampRate(tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3]))
          if cl > 0 then
            if tl > 0 and (cl ~= tl or cl ~= lastLevel[alias]) then
              monitoring[alias] = { ['ts'] = socket.gettime(), ['target'] = tl, ['current'] = cl, ['ramp'] = rr }
              if logging then log('Start monitor for '..alias..' target level='..tl..', current level='..cl..', ramp rate='..rr) end
            end
          end
        else
          monitoring[alias].current = cl
        end
        checkQueue() -- Check whether monitored groups are at target level
      end

    -- If the command contains a plus then it's a heartbeat
    elseif contains('+', cmd) then
      parts = string.split(cmd, '+')
      if parts[1] == 'MQTT' then
        MQTTheartbeat = tonumber(parts[2])
      end
    end
  end
  
  checkRampTermination() -- Check for terminated ramps (when ramped using a CBus key)

  --[[
  Heartbeats:

  The MQTT send/receive script may fail, stopping that script. To ensure it gets restarted without
  intervention, this script listens for a heartbeat from it every second. If heartbeats are not
  received within maxHeartbeat seconds then that script will be disabled and re-enabled.
  This caters for any situation where the Mosquitto library could encounter a race condition. With
  the current MQTT LUA code it is probably not possible. Probably. Leaving it here as belt/braces.

  ---- TODO ---- WTF?
  Ironically, a failure in this script will cause heartbeats to stop being received for some reason,
  causing repeated send/receive restarts. This script is simpler, though, so it should break less...
  A failure should cause re-entry because zero sleep, so should be good, but socket turns to custard.
  --]]

  MQTTsecondsSince = os.time() - MQTTheartbeat
  if MQTTsecondsSince >= maxHeartbeat then -- No heartbeat received for a while, so re-start the MQTT script
    log('Missed MQTT script heartbeats (last received '..MQTTsecondsSince..' seconds ago) - Re-starting MQTT script')
    script.disable('MQTT send/receive'); script.enable('MQTT send/receive')
    MQTTheartbeat = os.time()
  end
end
